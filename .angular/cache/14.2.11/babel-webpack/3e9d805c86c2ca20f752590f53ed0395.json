{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { CanvasElement } from 'angular-canvas';\nconst STEP = 5;\nconst SMOOTH = 30;\nlet NgGraph = class NgGraph {\n  constructor() {\n    this.deltaX = 0;\n    this.lineWidth = 1;\n    this.min = 0;\n    this.max = 100;\n    this.step = STEP;\n    this.horizontal = true; // Attributes\n\n    this.strokeStyle = 'black';\n    this.animationBlock = 1;\n  }\n\n  setNgProperty(name, value) {\n    if (name === 'data') {\n      if (this.data) {\n        this.oldData = this.data.slice();\n      }\n\n      this.data = value; // Init data\n\n      const oldData = this.oldData || new Array(this.data.length).fill(0);\n      this.waypointsData = calcWaypoints(oldData, this.data);\n      this.animationBlock = 1;\n    } else {\n      this[name] = value;\n    }\n\n    this.parent.drawAll();\n  }\n\n  setStyle(style, value, flags) {}\n\n  draw(context) {\n    if (this.data && this.data.length) {\n      context.strokeStyle = this.strokeStyle;\n      const numberOfBlock = this.animationBlock;\n      const index = this.waypointsData[numberOfBlock] ? numberOfBlock : this.waypointsData.length - 1;\n      const currentLines = this.waypointsData[index];\n      this.drawAnimate(context, currentLines);\n      this.animationBlock++;\n      this.needDraw = numberOfBlock < SMOOTH;\n    }\n  } // tslint:disable-next-line:typedef\n\n\n  drawAnimate(context, currentLines) {\n    const deltaX = this.deltaX;\n    const step = this.step;\n    const dxPointsCount = Math.floor(Math.abs(deltaX / step));\n    const viewPointsCount = Math.floor(Math.abs(this.getAxisSize(!this.horizontal) / step));\n    const viewLines = currentLines.slice(dxPointsCount, dxPointsCount + viewPointsCount);\n    const kY = this.getAxisSize(this.horizontal) / (this.max - this.min);\n    const horizontal = this.horizontal;\n    context.lineWidth = this.lineWidth;\n    context.beginPath();\n\n    for (let i = 0; i < viewLines.length; i++) {\n      const x = deltaX + (dxPointsCount + i) * step;\n      horizontal ? context.lineTo(x, viewLines[i] * kY) : context.lineTo(viewLines[i] * kY, x);\n    }\n\n    context.stroke();\n  }\n\n  getAxisSize(horizontal) {\n    const viewWidth = this.parent.element.width;\n    const viewHeight = this.parent.element.height;\n    return (horizontal ? viewHeight : viewWidth) / window.devicePixelRatio || 1;\n  }\n\n};\nNgGraph = __decorate([CanvasElement({\n  selector: 'graph-line'\n})], NgGraph);\nexport { NgGraph }; // TODO optimize it with one\n// calc waypoints traveling\n// tslint:disable-next-line:typedef\n\nfunction calcWaypoints(oldData, newData) {\n  const waypoints = [];\n  const dataPoints = [];\n\n  for (let i = 0; i < oldData.length; i++) {\n    const pt0 = oldData[i];\n    const pt1 = newData[i];\n    const dx = pt1 - pt0;\n    const points = [];\n\n    for (let j = 0; j < SMOOTH; j++) {\n      const x = pt0 + dx * j / SMOOTH;\n      points.push(x || 0);\n    }\n\n    dataPoints.push(points);\n  }\n\n  for (let j = 0; j < SMOOTH; j++) {\n    const data = [];\n\n    for (let i = 0; i < oldData.length; i++) {\n      data.push(dataPoints[i][j]);\n    }\n\n    waypoints.push(data);\n  }\n\n  return waypoints;\n}","map":null,"metadata":{},"sourceType":"module"}