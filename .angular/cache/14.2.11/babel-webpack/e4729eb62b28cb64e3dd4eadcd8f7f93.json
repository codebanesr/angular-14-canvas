{"ast":null,"code":"import { NgZone, Renderer2, RendererStyleFlags2, RendererType2, ViewEncapsulation } from '@angular/core';\nimport { NgCanvas } from './components/ng-canvas';\nimport { DefaultDomRenderer2, EmulatedEncapsulationDomRenderer2, ShadowDomRenderer } from './default-dom-renderer';\nimport { flattenStyles, NAMESPACE_URIS, shimContentAttribute, shimHostAttribute } from './renderer-utils';\nimport { getMetadataArgsStorage } from './metadata/metadata-storage';\nimport { CanvasRenderConfigModel } from './tokens/canvas-resize-obserer-enable-token';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/platform-browser\";\nexport let CanvasDomRendererFactory = /*#__PURE__*/(() => {\n  class CanvasDomRendererFactory {\n    constructor(eventManager, sharedStylesHost, appId, ngZone, canvasConfig) {\n      this.eventManager = eventManager;\n      this.sharedStylesHost = sharedStylesHost;\n      this.appId = appId;\n      this.ngZone = ngZone;\n      this.canvasConfig = canvasConfig;\n      this.rendererByCompId = new Map();\n      this.defaultRenderer = new DefaultDomRenderer2(eventManager);\n    }\n\n    end() {}\n\n    createRenderer(element, type) {\n      if (!element || !type) {\n        return this.defaultRenderer;\n      } // @ts-ignore\n\n\n      if (type['type'] && type['type'].isCanvasComponent) {\n        let renderer = this.rendererByCompId.get(type.id);\n\n        if (!renderer) {\n          renderer = new CanvasRenderer(this.eventManager, this.sharedStylesHost, type, this.appId, this.ngZone, this.canvasConfig);\n          this.rendererByCompId.set(type.id, renderer);\n        }\n\n        renderer.applyToHost(element);\n        return renderer;\n      }\n\n      switch (type.encapsulation) {\n        case ViewEncapsulation.Emulated:\n          {\n            let renderer = this.rendererByCompId.get(type.id);\n\n            if (!renderer) {\n              renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);\n              this.rendererByCompId.set(type.id, renderer);\n            }\n\n            renderer.applyToHost(element);\n            return renderer;\n          }\n\n        case ViewEncapsulation.ShadowDom:\n          return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);\n\n        default:\n          {\n            if (!this.rendererByCompId.has(type.id)) {\n              const styles = flattenStyles(type.id, type.styles, []);\n              this.sharedStylesHost.addStyles(styles);\n              this.rendererByCompId.set(type.id, this.defaultRenderer);\n            }\n\n            return this.defaultRenderer;\n          }\n      }\n    }\n\n  }\n\n  CanvasDomRendererFactory.ɵfac = function CanvasDomRendererFactory_Factory(t) {\n    i0.ɵɵinvalidFactory();\n  };\n\n  CanvasDomRendererFactory.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CanvasDomRendererFactory,\n    factory: CanvasDomRendererFactory.ɵfac\n  });\n  return CanvasDomRendererFactory;\n})();\nexport class CanvasRenderer {\n  constructor(eventManager, sharedStylesHost, component, appId, ngZone, config) {\n    this.component = component;\n    this.ngZone = ngZone;\n    this.config = config;\n    this.canvasElements = getMetadataArgsStorage().elements;\n    const styles = flattenStyles(appId + '-' + component.id, component.styles, []);\n    sharedStylesHost.addStyles(styles);\n    this.contentAttr = shimContentAttribute(appId + '-' + component.id);\n    this.hostAttr = shimHostAttribute(appId + '-' + component.id);\n  } // tslint:disable-next-line:typedef\n\n\n  applyToHost(element) {\n    this.setAttribute(element, this.hostAttr, '');\n  }\n\n  createElement(name, namespace) {\n    const Component = this.canvasElements.get(name);\n\n    if (Component) {\n      return new Component();\n    } else if (name === 'canvas') {\n      const canvas = new NgCanvas(this.ngZone, this.config);\n      canvas.element.setAttribute(this.contentAttr, '');\n      return canvas;\n    } else {\n      let element;\n\n      if (namespace) {\n        // In cases where Ivy (not ViewEngine) is giving us the actual namespace, the look up by key\n        // will result in undefined, so we just return the namespace here.\n        element = document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n      } else {\n        element = document.createElement(name);\n      }\n\n      this.setAttribute(element, this.contentAttr, '');\n      return element;\n    }\n  }\n\n  createText(value) {\n    return document.createTextNode(value);\n  }\n\n  selectRootElement(selectorOrNode, preserveContent) {\n    const el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) : selectorOrNode;\n\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n\n    if (!preserveContent) {\n      el.textContent = '';\n    }\n\n    return el;\n  }\n\n  addClass(el, name) {\n    if (el.classList) {\n      el.classList.add(name);\n    } else {\n      el.addClass(name);\n    }\n  }\n\n  removeClass(el, name) {\n    if (el.classList) {\n      el.classList.add(name);\n    } else {\n      el.removeClass(name);\n    }\n  }\n\n  appendChild(parent, newChild) {\n    // parent.appendChild(newChild);\n    if (!newChild) {\n      return;\n    }\n\n    newChild.parent = parent;\n\n    if (newChild instanceof NgCanvas) {\n      parent.appendChild(newChild.element);\n    } else {\n      parent.appendChild(newChild);\n    }\n  }\n\n  removeChild(parent, oldChild) {\n    // tslint:disable-next-line:no-unused-expression\n    oldChild.destroy && oldChild.destroy();\n\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n\n    if (oldChild && oldChild.parent instanceof NgCanvas) {\n      oldChild.parent.removeChild(oldChild);\n    }\n  }\n\n  createComment(value) {\n    return document.createComment(value);\n  }\n\n  destroy() {}\n\n  insertBefore(parent, newChild, refChild) {\n    if (parent && parent.insertBefore) {\n      newChild.parent = parent;\n\n      if (newChild instanceof NgCanvas) {\n        parent.insertBefore(newChild.element, refChild);\n      } else {\n        parent.insertBefore(newChild, refChild);\n      }\n    }\n  }\n\n  listen(target, eventName, callback) {\n    const callbackFunc = e => callback.call(target, e);\n\n    if (target instanceof NgCanvas) {\n      target = target.element;\n    }\n\n    target.addEventListener(eventName, callbackFunc);\n    return () => target.removeEventListener(eventName, callbackFunc);\n  } // tslint:disable-next-line:typedef\n\n\n  nextSibling(node) {\n    return {\n      previous: node,\n      next: node.nextSibling\n    };\n  }\n\n  parentNode(node) {\n    return node.parent ? node.parent : node;\n  }\n\n  removeAttribute(el, name, namespace) {\n    if (namespace) {\n      // TODO(FW-811): Ivy may cause issues here because it's passing around\n      // full URIs for namespaces, therefore this lookup will fail.\n      const namespaceUri = NAMESPACE_URIS[namespace];\n\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        // TODO(FW-811): Since ivy is passing around full URIs for namespaces\n        // this could result in properties like `http://www.w3.org/2000/svg:cx=\"123\"`,\n        // which is wrong.\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n\n  removeStyle(el, style, flags) {\n    el.removeStyle(style, flags);\n  }\n\n  setAttribute(el, name, value, namespace) {\n    if (namespace) {\n      name = namespace + ':' + name; // TODO(FW-811): Ivy may cause issues here because it's passing around\n      // full URIs for namespaces, therefore this lookup will fail.\n\n      const namespaceUri = NAMESPACE_URIS[namespace];\n\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n\n  setProperty(el, name, value) {\n    el.setNgProperty(name, value);\n  }\n\n  setStyle(el, style, value, flags) {\n    if (el.style) {\n      // tslint:disable-next-line:no-bitwise\n      if (flags & RendererStyleFlags2.DashCase) {\n        el.style.setProperty( // tslint:disable-next-line:no-bitwise\n        style, value, flags & RendererStyleFlags2.Important ? 'important' : '');\n      } else {\n        el.style[style] = value;\n      }\n    } else {\n      el.setStyle(style, value, flags);\n    }\n  }\n\n  setValue(node, value) {\n    if (node.setValue) {\n      node.setValue(value);\n    } else {\n      node.nodeValue = value;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}